
NEXT STEPS:

!!  Recording cannot exceed 25 Mb

!! change leaked top button to simple buttons in the view with 'gobackward' SF, in a gray.opacity circle

!! await MainActor.run { ... } instead of DispatchQueu.Main in async/await context

-- All transitions to be opacity.


1. delete item (locally and in the Pinecone), and Edit it. (updating the Pinecone)

3. Notifications (UserNotification) with the To-Do.

4. Widget with easy ask - insert (save new)

5. Check the whole app and replace all throw ... with AppError, check if additional cases are needed in the enum

6. Fail gracefully, all Errors in the API Operations should envoke some View and 'reset' the app for new recording

7. User LogIn , make seperate Pinecone index.

8. How to monitor user's  consumption/ credits

9. Firstly how to add Subscription (RevenueCat?)

10. UI Theme. make it nice, (!?) Use LottieFiles.


PINECONE COSTS FOR QUERY
The number of RUs used by a query is proportional to the following factors:

Record count: The number of vectors contained in the target index. Only vectors stored in the relevant namespace are used.
Record size: Higher dimensionality or larger metadata increases the size of each scanned vector.
Because serverless indexes organize vectors in similarity-based clusters, only a fraction of each index will be read for each query. The number of RUs a query uses therefore increases much more slowly than the index size.

The following table contains the RU cost of a query at different namespace sizes and record dimensionality, assuming an average metadata size around 500 bytes:

Records per namespace    Dimension=384    Dimension=768    Dimension=1536
100,000                     5 RUs               5 RUs              6 RUs






Write operations consume write units (WUs). Write units measure the storage and compute resources used to persist a record, make it available for querying, and update the clustered index to reflect its addition.

The following operations consume WUs:

Upsert
Update
Delete
​
Upsert
The number of WUs used by an upsert request is proportional to the total size of records it writes and/or modifies, with a minimum of 1 WU.

The following table contains the WU cost of an upsert request at different batch sizes and record dimensionality, assuming an average metadata size around 500 bytes:

Records per batch    Dimension=384    Dimension=768    Dimension=1536
    1                   3 WUs           4 WUs           7 WUs
    10                  30 WUs          40 WUs          70 WUs
    100                 300 WUs         400 WUs         700 WUs
​
Update
The number of WUs used when updating a record is proportional to the total size of the new or previous version of the record, whichever is larger, with a minimum of 1 WU.

The following table contains the WU cost of an update request at different dimensionalities and metadata sizes, with WUs based on the new or previous metadata size, whichever is larger:

Dimension    Previous metada size    New metadata size    WUs
768             400 bytes               500 bytes       4 WUs
1536            400 bytes               500 bytes       7 WUs
1536            4000 bytes              2000 bytes      11 WUs
​
Delete
The number of WUs used by a delete request is proportional to the total size of records it deletes, with a minimum of 1 WU.

The following table contains the WU cost of a delete request at different batch sizes and record dimensionality, assuming an average metadata size around 500 bytes:

Records per batch    Dimension=384    Dimension=768    Dimension=1536
1                       3 WUs           4 WUs               7 WUs
10                      30 WUs          40 WUs              70 WUs
100                     300 WUs         400 WUs             700 WUs

Specifying a non-existent ID or adding the same ID more than once does not increase WU use.

Deleting an entire namespace using the deleteAll flag always consumes 1 WU.

​
Storage
The size of an index is defined as the total size of its vectors across all namespaces. The size of a single vector is defined as the sum of three components:

ID size
Embedding size (equal to 4 times the vector’s dimensions)
Total metadata size (equal to the total size of all metadata fields)
The following table demonstrates a typical index size at different vector counts and dimensionality:

Records per namespace    Dimension=384    Dimension=768    Dimension=1536
100,000                 0.20 GB             0.35 GB         0.66 GB
1,000,000               2.00 GB             3.50 GB         6.60 GB
10,000,000              20.00 GB            35.00 GB        66.00 GB
​

====
Unlimited storage

$0.33 per GB/Month.

Unlimited writes

Starting at $2.00 per 1M Write Units

Unlimited reads

Starting at $8.25 per 1M Read Units
====
